"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/team/[id]/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCompetitions: () => (/* binding */ getCompetitions),\n/* harmony export */   getLastMatches: () => (/* binding */ getLastMatches),\n/* harmony export */   getNextMatches: () => (/* binding */ getNextMatches),\n/* harmony export */   getTeamInfo: () => (/* binding */ getTeamInfo),\n/* harmony export */   getTeamPlayers: () => (/* binding */ getTeamPlayers),\n/* harmony export */   getTeams: () => (/* binding */ getTeams)\n/* harmony export */ });\n// lib/api.ts\n// Utilisé par le front : appelle ton backend Next.js (app/api/...)\nasync function fetchJson(url, opts) {\n    const res = await fetch(url, {\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        ...opts\n    });\n    if (!res.ok) {\n        const text = await res.text().catch(()=>'');\n        throw new Error(\"Fetch error \".concat(res.status, \" \").concat(res.statusText, \" — \").concat(text));\n    }\n    return await res.json();\n}\n/**\n * Récupère la liste des compétitions via ton backend\n * Backend endpoint attendu : GET /api/competitions\n */ const getCompetitions = async ()=>{\n    return fetchJson('/api/competitions');\n};\n/**\n * Récupère les équipes d'une compétition via ton backend\n * Backend endpoint attendu : GET /api/teams/[competitionId]\n */ const getTeams = async (competitionId)=>{\n    return fetchJson(\"/api/teams/\".concat(competitionId));\n};\n/**\n * Récupère les derniers matchs d'une équipe via ton backend\n * Backend endpoint attendu : GET /api/teams/matches/[teamId]\n */ const getLastMatches = async (teamId)=>{\n    return fetchJson(\"/api/teams/matches/\".concat(teamId));\n};\n/**\n * Si tu veux récupérer les prochains matchs : soit ton backend gère un param type/ status,\n * soit tu crées un endpoint dédié. Exemple ci‑dessous en utilisant query param 'type=next'.\n *\n * Backend attendu : GET /api/teams/matches/[teamId]?type=next\n */ const getNextMatches = async (teamId)=>{\n    return fetchJson(\"/api/teams/matches/\".concat(teamId, \"?type=next\"));\n};\n/**\n * (Optionnel) Récupérer les infos d'une équipe si ton backend propose un endpoint dédié\n * Ex: GET /api/teams/info/[teamId]\n */ const getTeamInfo = async (teamId)=>{\n    return fetchJson(\"/api/teams/info/\".concat(teamId));\n};\n// export const getTeamPlayers = async (teamId: number): Promise<Player[]> => {\n//   const res = await fetchJson<any>(`/api/teams/players/${teamId}`)\n//   // Certains endpoints renvoient { squad: [...] } ou { players: [...] }\n//   if (Array.isArray(res)) return res\n//   if (res.players && Array.isArray(res.players)) return res.players\n//   if (res.squad && Array.isArray(res.squad)) return res.squad\n//   return []\n// }\nconst getTeamPlayers = async (teamId)=>{\n    const res = await fetchJson(\"/api/teams/players/\".concat(teamId));\n    console.log(res);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsYUFBYTtBQUNiLG1FQUFtRTtBQWtDbkUsZUFBZUEsVUFBbUJDLEdBQVcsRUFBRUMsSUFBa0I7SUFDL0QsTUFBTUMsTUFBTSxNQUFNQyxNQUFNSCxLQUFLO1FBQzNCSSxTQUFTO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzlDLEdBQUdILElBQUk7SUFDVDtJQUVBLElBQUksQ0FBQ0MsSUFBSUcsRUFBRSxFQUFFO1FBQ1gsTUFBTUMsT0FBTyxNQUFNSixJQUFJSSxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFNO1FBQzFDLE1BQU0sSUFBSUMsTUFBTSxlQUE2Qk4sT0FBZEEsSUFBSU8sTUFBTSxFQUFDLEtBQXVCSCxPQUFwQkosSUFBSVEsVUFBVSxFQUFDLE9BQVUsT0FBTEo7SUFDbkU7SUFFQSxPQUFRLE1BQU1KLElBQUlTLElBQUk7QUFDeEI7QUFFQTs7O0NBR0MsR0FDTSxNQUFNQyxrQkFBa0I7SUFDN0IsT0FBT2IsVUFBeUI7QUFDbEMsRUFBQztBQUVEOzs7Q0FHQyxHQUNNLE1BQU1jLFdBQVcsT0FBT0M7SUFDN0IsT0FBT2YsVUFBa0IsY0FBNEIsT0FBZGU7QUFDekMsRUFBQztBQUVEOzs7Q0FHQyxHQUNNLE1BQU1DLGlCQUFpQixPQUFPQztJQUNuQyxPQUFPakIsVUFBbUIsc0JBQTZCLE9BQVBpQjtBQUNsRCxFQUFDO0FBRUQ7Ozs7O0NBS0MsR0FDTSxNQUFNQyxpQkFBaUIsT0FBT0Q7SUFDbkMsT0FBT2pCLFVBQW1CLHNCQUE2QixPQUFQaUIsUUFBTztBQUN6RCxFQUFDO0FBRUQ7OztDQUdDLEdBQ00sTUFBTUUsY0FBYyxPQUFPRjtJQUNoQyxPQUFPakIsVUFBZ0IsbUJBQTBCLE9BQVBpQjtBQUM1QyxFQUFDO0FBRUQsK0VBQStFO0FBQy9FLHFFQUFxRTtBQUNyRSwyRUFBMkU7QUFDM0UsdUNBQXVDO0FBQ3ZDLHNFQUFzRTtBQUN0RSxnRUFBZ0U7QUFDaEUsY0FBYztBQUNkLElBQUk7QUFDRyxNQUFNRyxpQkFBaUIsT0FBT0g7SUFDbkMsTUFBTWQsTUFBTSxNQUFNSCxVQUFlLHNCQUE2QixPQUFQaUI7SUFDdkRJLFFBQVFDLEdBQUcsQ0FBQ25CO0FBR2QsRUFBQyIsInNvdXJjZXMiOlsiRDpcXGRldlxcRGV2UHJvamVjdFxcUHJvamVjdHNfVGVzdFxcRmFuWm9uZVxcbGliXFxhcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2FwaS50c1xuLy8gVXRpbGlzw6kgcGFyIGxlIGZyb250IDogYXBwZWxsZSB0b24gYmFja2VuZCBOZXh0LmpzIChhcHAvYXBpLy4uLilcbmV4cG9ydCB0eXBlIENvbXBldGl0aW9uID0ge1xuICBpZDogbnVtYmVyXG4gIG5hbWU6IHN0cmluZ1xuICBhcmVhPzogeyBuYW1lOiBzdHJpbmcgfVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIFRlYW0gPSB7XG4gIGlkOiBudW1iZXJcbiAgbmFtZTogc3RyaW5nXG4gIGNyZXN0Pzogc3RyaW5nXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTWF0Y2ggPSB7XG4gIGlkPzogbnVtYmVyXG4gIHV0Y0RhdGU/OiBzdHJpbmdcbiAgaG9tZVRlYW0/OiB7IGlkOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9XG4gIGF3YXlUZWFtPzogeyBpZDogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfVxuICBzY29yZT86IGFueVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIFBsYXllciA9IHsgXG4gIGlkPzogbnVtYmVyOyBcbiAgbmFtZTogc3RyaW5nOyBcbiAgcG9zaXRpb24/OiBzdHJpbmc7IFxuICBuYXRpb25hbGl0eT86IHN0cmluZzsgXG4gIGRhdGVPZkJpcnRoPzogc3RyaW5nOyBcbiAgW2s6IHN0cmluZ106IGFueSBcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaEpzb248VCA9IGFueT4odXJsOiBzdHJpbmcsIG9wdHM/OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8VD4ge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAuLi5vcHRzLFxuICB9KVxuXG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gJycpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGZXRjaCBlcnJvciAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IOKAlCAke3RleHR9YClcbiAgfVxuXG4gIHJldHVybiAoYXdhaXQgcmVzLmpzb24oKSkgYXMgVFxufVxuXG4vKipcbiAqIFLDqWN1cMOocmUgbGEgbGlzdGUgZGVzIGNvbXDDqXRpdGlvbnMgdmlhIHRvbiBiYWNrZW5kXG4gKiBCYWNrZW5kIGVuZHBvaW50IGF0dGVuZHUgOiBHRVQgL2FwaS9jb21wZXRpdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENvbXBldGl0aW9ucyA9IGFzeW5jICgpOiBQcm9taXNlPENvbXBldGl0aW9uW10+ID0+IHtcbiAgcmV0dXJuIGZldGNoSnNvbjxDb21wZXRpdGlvbltdPignL2FwaS9jb21wZXRpdGlvbnMnKVxufVxuXG4vKipcbiAqIFLDqWN1cMOocmUgbGVzIMOpcXVpcGVzIGQndW5lIGNvbXDDqXRpdGlvbiB2aWEgdG9uIGJhY2tlbmRcbiAqIEJhY2tlbmQgZW5kcG9pbnQgYXR0ZW5kdSA6IEdFVCAvYXBpL3RlYW1zL1tjb21wZXRpdGlvbklkXVxuICovXG5leHBvcnQgY29uc3QgZ2V0VGVhbXMgPSBhc3luYyAoY29tcGV0aXRpb25JZDogbnVtYmVyKTogUHJvbWlzZTxUZWFtW10+ID0+IHtcbiAgcmV0dXJuIGZldGNoSnNvbjxUZWFtW10+KGAvYXBpL3RlYW1zLyR7Y29tcGV0aXRpb25JZH1gKVxufVxuXG4vKipcbiAqIFLDqWN1cMOocmUgbGVzIGRlcm5pZXJzIG1hdGNocyBkJ3VuZSDDqXF1aXBlIHZpYSB0b24gYmFja2VuZFxuICogQmFja2VuZCBlbmRwb2ludCBhdHRlbmR1IDogR0VUIC9hcGkvdGVhbXMvbWF0Y2hlcy9bdGVhbUlkXVxuICovXG5leHBvcnQgY29uc3QgZ2V0TGFzdE1hdGNoZXMgPSBhc3luYyAodGVhbUlkOiBudW1iZXIpOiBQcm9taXNlPE1hdGNoW10+ID0+IHtcbiAgcmV0dXJuIGZldGNoSnNvbjxNYXRjaFtdPihgL2FwaS90ZWFtcy9tYXRjaGVzLyR7dGVhbUlkfWApXG59XG5cbi8qKlxuICogU2kgdHUgdmV1eCByw6ljdXDDqXJlciBsZXMgcHJvY2hhaW5zIG1hdGNocyA6IHNvaXQgdG9uIGJhY2tlbmQgZ8OocmUgdW4gcGFyYW0gdHlwZS8gc3RhdHVzLFxuICogc29pdCB0dSBjcsOpZXMgdW4gZW5kcG9pbnQgZMOpZGnDqS4gRXhlbXBsZSBjaeKAkWRlc3NvdXMgZW4gdXRpbGlzYW50IHF1ZXJ5IHBhcmFtICd0eXBlPW5leHQnLlxuICpcbiAqIEJhY2tlbmQgYXR0ZW5kdSA6IEdFVCAvYXBpL3RlYW1zL21hdGNoZXMvW3RlYW1JZF0/dHlwZT1uZXh0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXROZXh0TWF0Y2hlcyA9IGFzeW5jICh0ZWFtSWQ6IG51bWJlcik6IFByb21pc2U8TWF0Y2hbXT4gPT4ge1xuICByZXR1cm4gZmV0Y2hKc29uPE1hdGNoW10+KGAvYXBpL3RlYW1zL21hdGNoZXMvJHt0ZWFtSWR9P3R5cGU9bmV4dGApXG59XG5cbi8qKlxuICogKE9wdGlvbm5lbCkgUsOpY3Vww6lyZXIgbGVzIGluZm9zIGQndW5lIMOpcXVpcGUgc2kgdG9uIGJhY2tlbmQgcHJvcG9zZSB1biBlbmRwb2ludCBkw6lkacOpXG4gKiBFeDogR0VUIC9hcGkvdGVhbXMvaW5mby9bdGVhbUlkXVxuICovXG5leHBvcnQgY29uc3QgZ2V0VGVhbUluZm8gPSBhc3luYyAodGVhbUlkOiBudW1iZXIpOiBQcm9taXNlPGFueT4gPT4ge1xuICByZXR1cm4gZmV0Y2hKc29uPFRlYW0+KGAvYXBpL3RlYW1zL2luZm8vJHt0ZWFtSWR9YClcbn1cblxuLy8gZXhwb3J0IGNvbnN0IGdldFRlYW1QbGF5ZXJzID0gYXN5bmMgKHRlYW1JZDogbnVtYmVyKTogUHJvbWlzZTxQbGF5ZXJbXT4gPT4ge1xuLy8gICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaEpzb248YW55PihgL2FwaS90ZWFtcy9wbGF5ZXJzLyR7dGVhbUlkfWApXG4vLyAgIC8vIENlcnRhaW5zIGVuZHBvaW50cyByZW52b2llbnQgeyBzcXVhZDogWy4uLl0gfSBvdSB7IHBsYXllcnM6IFsuLi5dIH1cbi8vICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkgcmV0dXJuIHJlc1xuLy8gICBpZiAocmVzLnBsYXllcnMgJiYgQXJyYXkuaXNBcnJheShyZXMucGxheWVycykpIHJldHVybiByZXMucGxheWVyc1xuLy8gICBpZiAocmVzLnNxdWFkICYmIEFycmF5LmlzQXJyYXkocmVzLnNxdWFkKSkgcmV0dXJuIHJlcy5zcXVhZFxuLy8gICByZXR1cm4gW11cbi8vIH1cbmV4cG9ydCBjb25zdCBnZXRUZWFtUGxheWVycyA9IGFzeW5jICh0ZWFtSWQ6IG51bWJlcikgPT4ge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaEpzb248YW55PihgL2FwaS90ZWFtcy9wbGF5ZXJzLyR7dGVhbUlkfWApXG4gIGNvbnNvbGUubG9nKHJlcyk7XG4gIFxuXG59XG5cblxuIl0sIm5hbWVzIjpbImZldGNoSnNvbiIsInVybCIsIm9wdHMiLCJyZXMiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsInRleHQiLCJjYXRjaCIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImpzb24iLCJnZXRDb21wZXRpdGlvbnMiLCJnZXRUZWFtcyIsImNvbXBldGl0aW9uSWQiLCJnZXRMYXN0TWF0Y2hlcyIsInRlYW1JZCIsImdldE5leHRNYXRjaGVzIiwiZ2V0VGVhbUluZm8iLCJnZXRUZWFtUGxheWVycyIsImNvbnNvbGUiLCJsb2ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});